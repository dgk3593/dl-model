(function(){"use strict";const w=(e,t)=>t.some(n=>e instanceof n);let B,D;function E(){return B||(B=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function L(){return D||(D=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const y=new WeakMap,m=new WeakMap,f=new WeakMap;function S(e){const t=new Promise((n,r)=>{const o=()=>{e.removeEventListener("success",s),e.removeEventListener("error",a)},s=()=>{n(u(e.result)),o()},a=()=>{r(e.error),o()};e.addEventListener("success",s),e.addEventListener("error",a)});return f.set(t,e),t}function k(e){if(y.has(e))return;const t=new Promise((n,r)=>{const o=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",a),e.removeEventListener("abort",a)},s=()=>{n(),o()},a=()=>{r(e.error||new DOMException("AbortError","AbortError")),o()};e.addEventListener("complete",s),e.addEventListener("error",a),e.addEventListener("abort",a)});y.set(e,t)}let h={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return y.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function p(e){h=e(h)}function v(e){return L().includes(e)?function(...t){return e.apply(g(this),t),u(this.request)}:function(...t){return u(e.apply(g(this),t))}}function j(e){return typeof e=="function"?v(e):(e instanceof IDBTransaction&&k(e),w(e,E())?new Proxy(e,h):e)}function u(e){if(e instanceof IDBRequest)return S(e);if(m.has(e))return m.get(e);const t=j(e);return t!==e&&(m.set(e,t),f.set(t,e)),t}const g=e=>f.get(e);function A(e,t,{blocked:n,upgrade:r,blocking:o,terminated:s}={}){const a=indexedDB.open(e,t),c=u(a);return r&&a.addEventListener("upgradeneeded",i=>{r(u(a.result),i.oldVersion,i.newVersion,u(a.transaction),i)}),n&&a.addEventListener("blocked",i=>n(i.oldVersion,i.newVersion,i)),c.then(i=>{s&&i.addEventListener("close",()=>s()),o&&i.addEventListener("versionchange",l=>o(l.oldVersion,l.newVersion,l))}).catch(()=>{}),c}const V=["get","getKey","getAll","getAllKeys","count"],O=["put","add","delete","clear"],I=new Map;function M(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(I.get(t))return I.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,o=O.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(o||V.includes(n)))return;const s=async function(a,...c){const i=this.transaction(a,o?"readwrite":"readonly");let l=i.store;return r&&(l=l.index(c.shift())),(await Promise.all([l[n](...c),o&&i.done]))[0]};return I.set(t,s),s}p(e=>({...e,get:(t,n,r)=>M(t,n)||e.get(t,n,r),has:(t,n)=>!!M(t,n)||e.has(t,n)}));const K=["continue","continuePrimaryKey","advance"],x={},b=new WeakMap,C=new WeakMap,T={get(e,t){if(!K.includes(t))return e[t];let n=x[t];return n||(n=x[t]=function(...r){b.set(this,C.get(this)[t](...r))}),n}};async function*F(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,T);for(C.set(n,t),f.set(n,g(t));t;)yield n,t=await(b.get(n)||t.continue()),b.delete(n)}function P(e,t){return t===Symbol.asyncIterator&&w(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&w(e,[IDBIndex,IDBObjectStore])}p(e=>({...e,get(t,n,r){return P(t,n)?F:e.get(t,n,r)},has(t,n){return P(t,n)||e.has(t,n)}}));const d=A("model-viewer",3,{upgrade(e){e.objectStoreNames.contains("model")||e.createObjectStore("model",{keyPath:"id"}).createIndex("Name","name"),e.objectStoreNames.contains("animation")||e.createObjectStore("animation",{keyPath:"fullName"}).createIndex("User","user")}}),N=async(e,t)=>{const r=(await d).transaction(t,"readwrite"),o=e.map(s=>r.store.put(s));await Promise.all([...o,r.done])},R=async(e,t)=>await(await d).get(t,e),W=async(e,t,n)=>await(await d).getFromIndex(t,n,e),Q=async(e,t,n)=>await(await d).getAllFromIndex(t,n,e),U=async(e,t,n)=>{const r=await d,o=IDBKeyRange.bound(t,n);return await r.getAll(e,o)},$=async(e,t)=>{const n=new Map;let s=await(await d).transaction(e,"readonly").store.openCursor();for(;s;)n.set(s.key,t?s.value[t]:s.value),s=await s.continue();return n},z=async(e,t,n)=>{if(!e)return[];const r=[],s=(await d).transaction(t,"readonly"),a=e.toLowerCase();let c=await s.store.openCursor();for(;c;)(c.value[n]?.toLowerCase?.()).includes?.(a)&&r.push(c.value),c=await c.continue();return r};addEventListener("message",async e=>{const{type:t,store:n,value:r,index:o}=e.data;switch(t){case"put":await N(r,n),postMessage("");break;case"get":postMessage(await R(r,n));break;case"getByIndex":postMessage(await W(r,n,o));break;case"getAllByIndex":postMessage(await Q(r,n,o));break;case"getByKeyRange":const[s,a]=r.split("-");postMessage(await U(n,s,a));break;case"getMap":postMessage(await $(n,o));break;case"search":postMessage(await z(r,n,o))}})})();
