import{i as J,V as G,aw as q,ax as Z,o as P,am as $,ai as Q,af as C,P as v,ay as ee,k as se,ap as z,az as te,a3 as ne,aA as ie,aB as re,al as oe,aC as ae,aD as ce,e as le,R as ue,aE as fe,s as he}from"./422fb203-three.js";class K{constructor(){this.pluginCallbacks=[],this.register(function(e){return new we(e)}),this.register(function(e){return new Ie(e)}),this.register(function(e){return new Ne(e)}),this.register(function(e){return new Le(e)}),this.register(function(e){return new be(e)}),this.register(function(e){return new Se(e)}),this.register(function(e){return new Ae(e)}),this.register(function(e){return new Re(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,r,s){const i=new ye,n=[];for(let o=0,a=this.pluginCallbacks.length;o<a;o++)n.push(this.pluginCallbacks[o](i));i.setPlugins(n),i.write(e,t,s).catch(r)}parseAsync(e,t){const r=this;return new Promise(function(s,i){r.parse(e,s,i,t)})}}const x={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},R={};R[ne]=x.NEAREST;R[ie]=x.NEAREST_MIPMAP_NEAREST;R[re]=x.NEAREST_MIPMAP_LINEAR;R[oe]=x.LINEAR;R[ae]=x.LINEAR_MIPMAP_NEAREST;R[ce]=x.LINEAR_MIPMAP_LINEAR;R[le]=x.CLAMP_TO_EDGE;R[ue]=x.REPEAT;R[fe]=x.MIRRORED_REPEAT;const k={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},pe=new J,V=12,de=1179937895,ge=2,H=8,xe=1313821514,Te=5130562;function U(c,e){return c.length===e.length&&c.every(function(t,r){return t===e[r]})}function me(c){return new TextEncoder().encode(c).buffer}function Me(c){return U(c.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function Ee(c,e,t){const r={min:new Array(c.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(c.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let s=e;s<e+t;s++)for(let i=0;i<c.itemSize;i++){let n;c.itemSize>4?n=c.array[s*c.itemSize+i]:(i===0?n=c.getX(s):i===1?n=c.getY(s):i===2?n=c.getZ(s):i===3&&(n=c.getW(s)),c.normalized===!0&&(n=P.normalize(n,c.array))),r.min[i]=Math.min(r.min[i],n),r.max[i]=Math.max(r.max[i],n)}return r}function W(c){return Math.ceil(c/4)*4}function O(c,e=0){const t=W(c.byteLength);if(t!==c.byteLength){const r=new Uint8Array(t);if(r.set(new Uint8Array(c)),e!==0)for(let s=c.byteLength;s<t;s++)r[s]=e;return r.buffer}return c}function j(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function Y(c,e){if(c.toBlob!==void 0)return new Promise(r=>c.toBlob(r,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),c.convertToBlob({type:e,quality:t})}class ye{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,r={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},r),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const s=this,i=s.buffers,n=s.json;r=s.options;const o=s.extensionsUsed,a=new Blob(i,{type:"application/octet-stream"}),l=Object.keys(o);if(l.length>0&&(n.extensionsUsed=l),n.buffers&&n.buffers.length>0&&(n.buffers[0].byteLength=a.size),r.binary===!0){const p=new FileReader;p.readAsArrayBuffer(a),p.onloadend=function(){const u=O(p.result),T=new DataView(new ArrayBuffer(H));T.setUint32(0,u.byteLength,!0),T.setUint32(4,Te,!0);const f=O(me(JSON.stringify(n)),32),d=new DataView(new ArrayBuffer(H));d.setUint32(0,f.byteLength,!0),d.setUint32(4,xe,!0);const h=new ArrayBuffer(V),M=new DataView(h);M.setUint32(0,de,!0),M.setUint32(4,ge,!0);const m=V+d.byteLength+f.byteLength+T.byteLength+u.byteLength;M.setUint32(8,m,!0);const F=new Blob([h,d,f,T,u],{type:"application/octet-stream"}),g=new FileReader;g.readAsArrayBuffer(F),g.onloadend=function(){t(g.result)}}}else if(n.buffers&&n.buffers.length>0){const p=new FileReader;p.readAsDataURL(a),p.onloadend=function(){const u=p.result;n.buffers[0].uri=u,t(n)}}else t(n)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const r=this.options,s=this.extensionsUsed;try{const i=JSON.parse(JSON.stringify(e.userData));if(r.includeCustomExtensions&&i.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const n in i.gltfExtensions)t.extensions[n]=i.gltfExtensions[n],s[n]=!0;delete i.gltfExtensions}Object.keys(i).length>0&&(t.extras=i)}catch(i){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+i.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const s=new Map;s.set(!0,this.uid++),s.set(!1,this.uid++),this.uids.set(e,s)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const r=new G;for(let s=0,i=e.count;s<i;s++)if(Math.abs(r.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const r=e.clone(),s=new G;for(let i=0,n=r.count;i<n;i++)s.fromBufferAttribute(r,i),s.x===0&&s.y===0&&s.z===0?s.setX(1):s.normalize(),r.setXYZ(i,s.x,s.y,s.z);return t.attributesNormalized.set(e,r),r}applyTextureTransform(e,t){let r=!1;const s={};(t.offset.x!==0||t.offset.y!==0)&&(s.offset=t.offset.toArray(),r=!0),t.rotation!==0&&(s.rotation=t.rotation,r=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(s.scale=t.repeat.toArray(),r=!0),r&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=s,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function r(f){return f.encoding===he?function(h){return h<.04045?h*.0773993808:Math.pow(h*.9478672986+.0521327014,2.4)}:function(h){return h}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");const s=e?e.image:null,i=t?t.image:null,n=Math.max(s?s.width:0,i?i.width:0),o=Math.max(s?s.height:0,i?i.height:0),a=j();a.width=n,a.height=o;const l=a.getContext("2d");l.fillStyle="#00ffff",l.fillRect(0,0,n,o);const p=l.getImageData(0,0,n,o);if(s){l.drawImage(s,0,0,n,o);const f=r(e),d=l.getImageData(0,0,n,o).data;for(let h=2;h<d.length;h+=4)p.data[h]=f(d[h]/256)*256}if(i){l.drawImage(i,0,0,n,o);const f=r(t),d=l.getImageData(0,0,n,o).data;for(let h=1;h<d.length;h+=4)p.data[h]=f(d[h]/256)*256}l.putImageData(p,0,0);const T=(e||t).clone();return T.source=new q(a),T.encoding=Z,T}processBuffer(e){const t=this.json,r=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),r.push(e),0}processBufferView(e,t,r,s,i){const n=this.json;n.bufferViews||(n.bufferViews=[]);let o;t===x.UNSIGNED_BYTE?o=1:t===x.UNSIGNED_SHORT?o=2:o=4;const a=W(s*e.itemSize*o),l=new DataView(new ArrayBuffer(a));let p=0;for(let f=r;f<r+s;f++)for(let d=0;d<e.itemSize;d++){let h;e.itemSize>4?h=e.array[f*e.itemSize+d]:(d===0?h=e.getX(f):d===1?h=e.getY(f):d===2?h=e.getZ(f):d===3&&(h=e.getW(f)),e.normalized===!0&&(h=P.normalize(h,e.array))),t===x.FLOAT?l.setFloat32(p,h,!0):t===x.UNSIGNED_INT?l.setUint32(p,h,!0):t===x.UNSIGNED_SHORT?l.setUint16(p,h,!0):t===x.UNSIGNED_BYTE&&l.setUint8(p,h),p+=o}const u={buffer:this.processBuffer(l.buffer),byteOffset:this.byteOffset,byteLength:a};return i!==void 0&&(u.target=i),i===x.ARRAY_BUFFER&&(u.byteStride=e.itemSize*o),this.byteOffset+=a,n.bufferViews.push(u),{id:n.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,r=t.json;return r.bufferViews||(r.bufferViews=[]),new Promise(function(s){const i=new FileReader;i.readAsArrayBuffer(e),i.onloadend=function(){const n=O(i.result),o={buffer:t.processBuffer(n),byteOffset:t.byteOffset,byteLength:n.byteLength};t.byteOffset+=n.byteLength,s(r.bufferViews.push(o)-1)}})}processAccessor(e,t,r,s){const i=this.json,n={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"};let o;if(e.array.constructor===Float32Array)o=x.FLOAT;else if(e.array.constructor===Uint32Array)o=x.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)o=x.UNSIGNED_SHORT;else if(e.array.constructor===Uint8Array)o=x.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");if(r===void 0&&(r=0),s===void 0&&(s=e.count),s===0)return null;const a=Ee(e,r,s);let l;t!==void 0&&(l=e===t.index?x.ELEMENT_ARRAY_BUFFER:x.ARRAY_BUFFER);const p=this.processBufferView(e,o,r,s,l),u={bufferView:p.id,byteOffset:p.byteOffset,componentType:o,count:s,max:a.max,min:a.min,type:n[e.itemSize]};return e.normalized===!0&&(u.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(u)-1}processImage(e,t,r,s="image/png"){if(e!==null){const i=this,n=i.cache,o=i.json,a=i.options,l=i.pending;n.images.has(e)||n.images.set(e,{});const p=n.images.get(e),u=s+":flipY/"+r.toString();if(p[u]!==void 0)return p[u];o.images||(o.images=[]);const T={mimeType:s},f=j();f.width=Math.min(e.width,a.maxTextureSize),f.height=Math.min(e.height,a.maxTextureSize);const d=f.getContext("2d");if(r===!0&&(d.translate(0,f.height),d.scale(1,-1)),e.data!==void 0){t!==$&&console.error("GLTFExporter: Only RGBAFormat is supported."),(e.width>a.maxTextureSize||e.height>a.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const M=new Uint8ClampedArray(e.height*e.width*4);for(let m=0;m<M.length;m+=4)M[m+0]=e.data[m+0],M[m+1]=e.data[m+1],M[m+2]=e.data[m+2],M[m+3]=e.data[m+3];d.putImageData(new ImageData(M,e.width,e.height),0,0)}else d.drawImage(e,0,0,f.width,f.height);a.binary===!0?l.push(Y(f,s).then(M=>i.processBufferViewImage(M)).then(M=>{T.bufferView=M})):f.toDataURL!==void 0?T.uri=f.toDataURL(s):l.push(Y(f,s).then(M=>new FileReader().readAsDataURL(M)).then(M=>{T.uri=M}));const h=o.images.push(T)-1;return p[u]=h,h}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const r={magFilter:R[e.magFilter],minFilter:R[e.minFilter],wrapS:R[e.wrapS],wrapT:R[e.wrapT]};return t.samplers.push(r)-1}processTexture(e){const t=this.cache,r=this.json;if(t.textures.has(e))return t.textures.get(e);r.textures||(r.textures=[]);let s=e.userData.mimeType;s==="image/webp"&&(s="image/png");const i={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,s)};e.name&&(i.name=e.name),this._invokeAll(function(o){o.writeTexture&&o.writeTexture(e,i)});const n=r.textures.push(i)-1;return t.textures.set(e,n),n}processMaterial(e){const t=this.cache,r=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;r.materials||(r.materials=[]);const s={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const i=e.color.toArray().concat([e.opacity]);if(U(i,[1,1,1,1])||(s.pbrMetallicRoughness.baseColorFactor=i),e.isMeshStandardMaterial?(s.pbrMetallicRoughness.metallicFactor=e.metalness,s.pbrMetallicRoughness.roughnessFactor=e.roughness):(s.pbrMetallicRoughness.metallicFactor=.5,s.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const o=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),a={index:this.processTexture(o)};this.applyTextureTransform(a,o),s.pbrMetallicRoughness.metallicRoughnessTexture=a}if(e.map){const o={index:this.processTexture(e.map)};this.applyTextureTransform(o,e.map),s.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive.clone().multiplyScalar(e.emissiveIntensity),a=Math.max(o.r,o.g,o.b);if(a>1&&(o.multiplyScalar(1/a),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),a>0&&(s.emissiveFactor=o.toArray()),e.emissiveMap){const l={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(l,e.emissiveMap),s.emissiveTexture=l}}if(e.normalMap){const o={index:this.processTexture(e.normalMap)};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),s.normalTexture=o}if(e.aoMap){const o={index:this.processTexture(e.aoMap),texCoord:1};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),s.occlusionTexture=o}e.transparent?s.alphaMode="BLEND":e.alphaTest>0&&(s.alphaMode="MASK",s.alphaCutoff=e.alphaTest),e.side===Q&&(s.doubleSided=!0),e.name!==""&&(s.name=e.name),this.serializeUserData(e,s),this._invokeAll(function(o){o.writeMaterial&&o.writeMaterial(e,s)});const n=r.materials.push(s)-1;return t.materials.set(e,n),n}processMesh(e){const t=this.cache,r=this.json,s=[e.geometry.uuid];if(Array.isArray(e.material))for(let g=0,E=e.material.length;g<E;g++)s.push(e.material[g].uuid);else s.push(e.material.uuid);const i=s.join(":");if(t.meshes.has(i))return t.meshes.get(i);const n=e.geometry;let o;e.isLineSegments?o=x.LINES:e.isLineLoop?o=x.LINE_LOOP:e.isLine?o=x.LINE_STRIP:e.isPoints?o=x.POINTS:o=e.material.wireframe?x.LINES:x.TRIANGLES;const a={},l={},p=[],u=[],T={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},f=n.getAttribute("normal");f!==void 0&&!this.isNormalizedNormalAttribute(f)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),n.setAttribute("normal",this.createNormalizedNormalAttribute(f)));let d=null;for(let g in n.attributes){if(g.slice(0,5)==="morph")continue;const E=n.attributes[g];if(g=T[g]||g.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(g)||(g="_"+g),t.attributes.has(this.getUID(E))){l[g]=t.attributes.get(this.getUID(E));continue}d=null;const y=E.array;g==="JOINTS_0"&&!(y instanceof Uint16Array)&&!(y instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),d=new C(new Uint16Array(y),E.itemSize,E.normalized));const A=this.processAccessor(d||E,n);A!==null&&(l[g]=A,t.attributes.set(this.getUID(E),A))}if(f!==void 0&&n.setAttribute("normal",f),Object.keys(l).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const g=[],E=[],I={};if(e.morphTargetDictionary!==void 0)for(const y in e.morphTargetDictionary)I[e.morphTargetDictionary[y]]=y;for(let y=0;y<e.morphTargetInfluences.length;++y){const A={};let B=!1;for(const b in n.morphAttributes){if(b!=="position"&&b!=="normal"){B||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),B=!0);continue}const N=n.morphAttributes[b][y],D=b.toUpperCase(),S=n.attributes[b];if(t.attributes.has(this.getUID(N,!0))){A[D]=t.attributes.get(this.getUID(N,!0));continue}const _=N.clone();if(!n.morphTargetsRelative)for(let w=0,X=N.count;w<X;w++)for(let L=0;L<N.itemSize;L++)L===0&&_.setX(w,N.getX(w)-S.getX(w)),L===1&&_.setY(w,N.getY(w)-S.getY(w)),L===2&&_.setZ(w,N.getZ(w)-S.getZ(w)),L===3&&_.setW(w,N.getW(w)-S.getW(w));A[D]=this.processAccessor(_,n),t.attributes.set(this.getUID(S,!0),A[D])}u.push(A),g.push(e.morphTargetInfluences[y]),e.morphTargetDictionary!==void 0&&E.push(I[y])}a.weights=g,E.length>0&&(a.extras={},a.extras.targetNames=E)}const h=Array.isArray(e.material);if(h&&n.groups.length===0)return null;const M=h?e.material:[e.material],m=h?n.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let g=0,E=m.length;g<E;g++){const I={mode:o,attributes:l};if(this.serializeUserData(n,I),u.length>0&&(I.targets=u),n.index!==null){let A=this.getUID(n.index);(m[g].start!==void 0||m[g].count!==void 0)&&(A+=":"+m[g].start+":"+m[g].count),t.attributes.has(A)?I.indices=t.attributes.get(A):(I.indices=this.processAccessor(n.index,n,m[g].start,m[g].count),t.attributes.set(A,I.indices)),I.indices===null&&delete I.indices}const y=this.processMaterial(M[m[g].materialIndex]);y!==null&&(I.material=y),p.push(I)}a.primitives=p,r.meshes||(r.meshes=[]),this._invokeAll(function(g){g.writeMesh&&g.writeMesh(e,a)});const F=r.meshes.push(a)-1;return t.meshes.set(i,F),F}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const r=e.isOrthographicCamera,s={type:r?"orthographic":"perspective"};return r?s.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:s.perspective={aspectRatio:e.aspect,yfov:P.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(s.name=e.type),t.cameras.push(s)-1}processAnimation(e,t){const r=this.json,s=this.nodeMap;r.animations||(r.animations=[]),e=K.Utils.mergeMorphTargetTracks(e.clone(),t);const i=e.tracks,n=[],o=[];for(let a=0;a<i.length;++a){const l=i[a],p=v.parseTrackName(l.name);let u=v.findNode(t,p.nodeName);const T=k[p.propertyName];if(p.objectName==="bones"&&(u.isSkinnedMesh===!0?u=u.skeleton.getBoneByName(p.objectIndex):u=void 0),!u||!T)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',l.name),null;const f=1;let d=l.values.length/l.times.length;T===k.morphTargetInfluences&&(d/=u.morphTargetInfluences.length);let h;l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(h="CUBICSPLINE",d/=3):l.getInterpolation()===ee?h="STEP":h="LINEAR",o.push({input:this.processAccessor(new C(l.times,f)),output:this.processAccessor(new C(l.values,d)),interpolation:h}),n.push({sampler:o.length-1,target:{node:s.get(u),path:T}})}return r.animations.push({name:e.name||"clip_"+r.animations.length,samplers:o,channels:n}),r.animations.length-1}processSkin(e){const t=this.json,r=this.nodeMap,s=t.nodes[r.get(e)],i=e.skeleton;if(i===void 0)return null;const n=e.skeleton.bones[0];if(n===void 0)return null;const o=[],a=new Float32Array(i.bones.length*16),l=new se;for(let u=0;u<i.bones.length;++u)o.push(r.get(i.bones[u])),l.copy(i.boneInverses[u]),l.multiply(e.bindMatrix).toArray(a,u*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new C(a,16)),joints:o,skeleton:r.get(n)}),s.skin=t.skins.length-1}processNode(e){const t=this.json,r=this.options,s=this.nodeMap;t.nodes||(t.nodes=[]);const i={};if(r.trs){const o=e.quaternion.toArray(),a=e.position.toArray(),l=e.scale.toArray();U(o,[0,0,0,1])||(i.rotation=o),U(a,[0,0,0])||(i.translation=a),U(l,[1,1,1])||(i.scale=l)}else e.matrixAutoUpdate&&e.updateMatrix(),Me(e.matrix)===!1&&(i.matrix=e.matrix.elements);if(e.name!==""&&(i.name=String(e.name)),this.serializeUserData(e,i),e.isMesh||e.isLine||e.isPoints){const o=this.processMesh(e);o!==null&&(i.mesh=o)}else e.isCamera&&(i.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const o=[];for(let a=0,l=e.children.length;a<l;a++){const p=e.children[a];if(p.visible||r.onlyVisible===!1){const u=this.processNode(p);u!==null&&o.push(u)}}o.length>0&&(i.children=o)}this._invokeAll(function(o){o.writeNode&&o.writeNode(e,i)});const n=t.nodes.push(i)-1;return s.set(e,n),n}processScene(e){const t=this.json,r=this.options;t.scenes||(t.scenes=[],t.scene=0);const s={};e.name!==""&&(s.name=e.name),t.scenes.push(s);const i=[];for(let n=0,o=e.children.length;n<o;n++){const a=e.children[n];if(a.visible||r.onlyVisible===!1){const l=this.processNode(a);l!==null&&i.push(l)}}i.length>0&&(s.nodes=i),this.serializeUserData(e,s)}processObjects(e){const t=new z;t.name="AuxScene";for(let r=0;r<e.length;r++)t.children.push(e[r]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(s){s.beforeParse&&s.beforeParse(e)});const r=[];for(let s=0;s<e.length;s++)e[s]instanceof z?this.processScene(e[s]):r.push(e[s]);r.length>0&&this.processObjects(r);for(let s=0;s<this.skins.length;++s)this.processSkin(this.skins[s]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);this._invokeAll(function(s){s.afterParse&&s.afterParse(e)})}_invokeAll(e){for(let t=0,r=this.plugins.length;t<r;t++)e(this.plugins[t])}}class we{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const r=this.writer,s=r.json,i=r.extensionsUsed,n={};e.name&&(n.name=e.name),n.color=e.color.toArray(),n.intensity=e.intensity,e.isDirectionalLight?n.type="directional":e.isPointLight?(n.type="point",e.distance>0&&(n.range=e.distance)):e.isSpotLight&&(n.type="spot",e.distance>0&&(n.range=e.distance),n.spot={},n.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,n.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),i[this.name]||(s.extensions=s.extensions||{},s.extensions[this.name]={lights:[]},i[this.name]=!0);const o=s.extensions[this.name].lights;o.push(n),t.extensions=t.extensions||{},t.extensions[this.name]={light:o.length-1}}}class Ie{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class Ae{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const r=this.writer,s=r.extensionsUsed,i={};if(i.clearcoatFactor=e.clearcoat,e.clearcoatMap){const n={index:r.processTexture(e.clearcoatMap)};r.applyTextureTransform(n,e.clearcoatMap),i.clearcoatTexture=n}if(i.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const n={index:r.processTexture(e.clearcoatRoughnessMap)};r.applyTextureTransform(n,e.clearcoatRoughnessMap),i.clearcoatRoughnessTexture=n}if(e.clearcoatNormalMap){const n={index:r.processTexture(e.clearcoatNormalMap)};r.applyTextureTransform(n,e.clearcoatNormalMap),i.clearcoatNormalTexture=n}t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Re{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const r=this.writer,s=r.extensionsUsed,i={};if(i.iridescenceFactor=e.iridescence,e.iridescenceMap){const n={index:r.processTexture(e.iridescenceMap)};r.applyTextureTransform(n,e.iridescenceMap),i.iridescenceTexture=n}if(i.iridescenceIor=e.iridescenceIOR,i.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],i.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const n={index:r.processTexture(e.iridescenceThicknessMap)};r.applyTextureTransform(n,e.iridescenceThicknessMap),i.iridescenceThicknessTexture=n}t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Ne{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const r=this.writer,s=r.extensionsUsed,i={};if(i.transmissionFactor=e.transmission,e.transmissionMap){const n={index:r.processTexture(e.transmissionMap)};r.applyTextureTransform(n,e.transmissionMap),i.transmissionTexture=n}t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Le{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const r=this.writer,s=r.extensionsUsed,i={};if(i.thicknessFactor=e.thickness,e.thicknessMap){const n={index:r.processTexture(e.thicknessMap)};r.applyTextureTransform(n,e.thicknessMap),i.thicknessTexture=n}i.attenuationDistance=e.attenuationDistance,i.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class be{constructor(e){this.writer=e,this.name="KHR_materials_ior"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const s=this.writer.extensionsUsed,i={};i.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}class Se{constructor(e){this.writer=e,this.name="KHR_materials_specular"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(pe)&&!e.specularIntensityMap&&!e.specularColorTexture)return;const r=this.writer,s=r.extensionsUsed,i={};if(e.specularIntensityMap){const n={index:r.processTexture(e.specularIntensityMap)};r.applyTextureTransform(n,e.specularIntensityMap),i.specularTexture=n}if(e.specularColorMap){const n={index:r.processTexture(e.specularColorMap)};r.applyTextureTransform(n,e.specularColorMap),i.specularColorTexture=n}i.specularFactor=e.specularIntensity,i.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=i,s[this.name]=!0}}K.Utils={insertKeyframe:function(c,e){const r=c.getValueSize(),s=new c.TimeBufferType(c.times.length+1),i=new c.ValueBufferType(c.values.length+r),n=c.createInterpolant(new c.ValueBufferType(r));let o;if(c.times.length===0){s[0]=e;for(let a=0;a<r;a++)i[a]=0;o=0}else if(e<c.times[0]){if(Math.abs(c.times[0]-e)<.001)return 0;s[0]=e,s.set(c.times,1),i.set(n.evaluate(e),0),i.set(c.values,r),o=0}else if(e>c.times[c.times.length-1]){if(Math.abs(c.times[c.times.length-1]-e)<.001)return c.times.length-1;s[s.length-1]=e,s.set(c.times,0),i.set(c.values,0),i.set(n.evaluate(e),c.values.length),o=s.length-1}else for(let a=0;a<c.times.length;a++){if(Math.abs(c.times[a]-e)<.001)return a;if(c.times[a]<e&&c.times[a+1]>e){s.set(c.times.slice(0,a+1),0),s[a+1]=e,s.set(c.times.slice(a+1),a+2),i.set(c.values.slice(0,(a+1)*r),0),i.set(n.evaluate(e),(a+1)*r),i.set(c.values.slice((a+1)*r),(a+2)*r),o=a+1;break}}return c.times=s,c.values=i,o},mergeMorphTargetTracks:function(c,e){const t=[],r={},s=c.tracks;for(let i=0;i<s.length;++i){let n=s[i];const o=v.parseTrackName(n.name),a=v.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){t.push(n);continue}if(n.createInterpolant!==n.InterpolantFactoryMethodDiscrete&&n.createInterpolant!==n.InterpolantFactoryMethodLinear){if(n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),n=n.clone(),n.setInterpolation(te)}const l=a.morphTargetInfluences.length,p=a.morphTargetDictionary[o.propertyIndex];if(p===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let u;if(r[a.uuid]===void 0){u=n.clone();const f=new u.ValueBufferType(l*u.times.length);for(let d=0;d<u.times.length;d++)f[d*l+p]=u.values[d];u.name=(o.nodeName||"")+".morphTargetInfluences",u.values=f,r[a.uuid]=u,t.push(u);continue}const T=n.createInterpolant(new n.ValueBufferType(1));u=r[a.uuid];for(let f=0;f<u.times.length;f++)u.values[f*l+p]=T.evaluate(u.times[f]);for(let f=0;f<n.times.length;f++){const d=this.insertKeyframe(u,n.times[f]);u.values[d*l+p]=n.values[f]}}return c.tracks=t,c}};export{K as GLTFExporter};
