import{C as $,b as Z,c as z,Q as ee,B as b,R as se,d as P,e as te,f as ne,g as H,h as ie,I as re,i as oe,P as D,j as ae,k as Y,l as ce,N as le,m as ue,n as he,L as fe,o as pe,p as de,q as xe,r as ye,s as ge,t as Te}from"./f_BX0KNnxF-three.js";const K={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class O{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(e){return new _e(e)}),this.register(function(e){return new be(e)}),this.register(function(e){return new ve(e)}),this.register(function(e){return new Oe(e)}),this.register(function(e){return new ze(e)}),this.register(function(e){return new De(e)}),this.register(function(e){return new Ce(e)}),this.register(function(e){return new Ue(e)}),this.register(function(e){return new Fe(e)}),this.register(function(e){return new Be(e)}),this.register(function(e){return new Pe(e)}),this.register(function(e){return new Ge(e)}),this.register(function(e){return new ke(e)}),this.register(function(e){return new He(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}setTextureUtils(e){return this.textureUtils=e,this}parse(e,s,r,t){const n=new Se,i=[];for(let o=0,c=this.pluginCallbacks.length;o<c;o++)i.push(this.pluginCallbacks[o](n));n.setPlugins(i),n.setTextureUtils(this.textureUtils),n.writeAsync(e,s,t).catch(r)}parseAsync(e,s){const r=this;return new Promise(function(t,n){r.parse(e,t,n,s)})}}const T={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},G="KHR_mesh_quantization",N={};N[le]=T.NEAREST;N[ue]=T.NEAREST_MIPMAP_NEAREST;N[he]=T.NEAREST_MIPMAP_LINEAR;N[fe]=T.LINEAR;N[pe]=T.LINEAR_MIPMAP_NEAREST;N[de]=T.LINEAR_MIPMAP_LINEAR;N[xe]=T.CLAMP_TO_EDGE;N[ye]=T.REPEAT;N[ge]=T.MIRRORED_REPEAT;const q={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},we=new $,W=12,me=1179937895,Me=2,X=8,Ae=1313821514,Ee=5130562;function S(a,e){return a.length===e.length&&a.every(function(s,r){return s===e[r]})}function Ie(a){return new TextEncoder().encode(a).buffer}function Re(a){return S(a.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function Ne(a,e,s){const r={min:new Array(a.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(a.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let t=e;t<e+s;t++)for(let n=0;n<a.itemSize;n++){let i;a.itemSize>4?i=a.array[t*a.itemSize+n]:(n===0?i=a.getX(t):n===1?i=a.getY(t):n===2?i=a.getZ(t):n===3&&(i=a.getW(t)),a.normalized===!0&&(i=H.normalize(i,a.array))),r.min[n]=Math.min(r.min[n],i),r.max[n]=Math.max(r.max[n],i)}return r}function j(a){return Math.ceil(a/4)*4}function k(a,e=0){const s=j(a.byteLength);if(s!==a.byteLength){const r=new Uint8Array(s);if(r.set(new Uint8Array(a)),e!==0)for(let t=a.byteLength;t<s;t++)r[t]=e;return r.buffer}return a}function J(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function Le(a,e){if(typeof OffscreenCanvas<"u"&&a instanceof OffscreenCanvas){let s;return e==="image/jpeg"?s=.92:e==="image/webp"&&(s=.8),a.convertToBlob({type:e,quality:s})}else return new Promise(s=>a.toBlob(s,e))}class Se{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+se}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(e){this.plugins=e}setTextureUtils(e){this.textureUtils=e}async writeAsync(e,s,r={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},r),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(e),await Promise.all(this.pending);const t=this,n=t.buffers,i=t.json;r=t.options;const o=t.extensionsUsed,c=t.extensionsRequired,u=new Blob(n,{type:"application/octet-stream"}),f=Object.keys(o),l=Object.keys(c);if(f.length>0&&(i.extensionsUsed=f),l.length>0&&(i.extensionsRequired=l),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=u.size),r.binary===!0){const g=new FileReader;g.readAsArrayBuffer(u),g.onloadend=function(){const h=k(g.result),x=new DataView(new ArrayBuffer(X));x.setUint32(0,h.byteLength,!0),x.setUint32(4,Ee,!0);const p=k(Ie(JSON.stringify(i)),32),d=new DataView(new ArrayBuffer(X));d.setUint32(0,p.byteLength,!0),d.setUint32(4,Ae,!0);const m=new ArrayBuffer(W),A=new DataView(m);A.setUint32(0,me,!0),A.setUint32(4,Me,!0);const _=W+d.byteLength+p.byteLength+x.byteLength+h.byteLength;A.setUint32(8,_,!0);const y=new Blob([m,d,p,x,h],{type:"application/octet-stream"}),w=new FileReader;w.readAsArrayBuffer(y),w.onloadend=function(){s(w.result)}}}else if(i.buffers&&i.buffers.length>0){const g=new FileReader;g.readAsDataURL(u),g.onloadend=function(){const h=g.result;i.buffers[0].uri=h,s(i)}}else s(i)}serializeUserData(e,s){if(Object.keys(e.userData).length===0)return;const r=this.options,t=this.extensionsUsed;try{const n=JSON.parse(JSON.stringify(e.userData));if(r.includeCustomExtensions&&n.gltfExtensions){s.extensions===void 0&&(s.extensions={});for(const i in n.gltfExtensions)s.extensions[i]=n.gltfExtensions[i],t[i]=!0;delete n.gltfExtensions}Object.keys(n).length>0&&(s.extras=n)}catch(n){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+n.message)}}getUID(e,s=!1){if(this.uids.has(e)===!1){const t=new Map;t.set(!0,this.uid++),t.set(!1,this.uid++),this.uids.set(e,t)}return this.uids.get(e).get(s)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const r=new z;for(let t=0,n=e.count;t<n;t++)if(Math.abs(r.fromBufferAttribute(e,t).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const s=this.cache;if(s.attributesNormalized.has(e))return s.attributesNormalized.get(e);const r=e.clone(),t=new z;for(let n=0,i=r.count;n<i;n++)t.fromBufferAttribute(r,n),t.x===0&&t.y===0&&t.z===0?t.setX(1):t.normalize(),r.setXYZ(n,t.x,t.y,t.z);return s.attributesNormalized.set(e,r),r}applyTextureTransform(e,s){let r=!1;const t={};(s.offset.x!==0||s.offset.y!==0)&&(t.offset=s.offset.toArray(),r=!0),s.rotation!==0&&(t.rotation=s.rotation,r=!0),(s.repeat.x!==1||s.repeat.y!==1)&&(t.scale=s.repeat.toArray(),r=!0),r&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=t,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(e,s){if(e===s)return e;function r(h){return h.colorSpace===ce?function(p){return p<.04045?p*.0773993808:Math.pow(p*.9478672986+.0521327014,2.4)}:function(p){return p}}e instanceof P&&(e=await this.decompressTextureAsync(e)),s instanceof P&&(s=await this.decompressTextureAsync(s));const t=e?e.image:null,n=s?s.image:null,i=Math.max(t?t.width:0,n?n.width:0),o=Math.max(t?t.height:0,n?n.height:0),c=J();c.width=i,c.height=o;const u=c.getContext("2d",{willReadFrequently:!0});u.fillStyle="#00ffff",u.fillRect(0,0,i,o);const f=u.getImageData(0,0,i,o);if(t){u.drawImage(t,0,0,i,o);const h=r(e),x=u.getImageData(0,0,i,o).data;for(let p=2;p<x.length;p+=4)f.data[p]=h(x[p]/256)*256}if(n){u.drawImage(n,0,0,i,o);const h=r(s),x=u.getImageData(0,0,i,o).data;for(let p=1;p<x.length;p+=4)f.data[p]=h(x[p]/256)*256}u.putImageData(f,0,0);const g=(e||s).clone();return g.source=new te(c),g.colorSpace=ne,g.channel=(e||s).channel,e&&s&&e.channel!==s.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),g}async decompressTextureAsync(e,s=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(e,s)}processBuffer(e){const s=this.json,r=this.buffers;return s.buffers||(s.buffers=[{byteLength:0}]),r.push(e),0}processBufferView(e,s,r,t,n){const i=this.json;i.bufferViews||(i.bufferViews=[]);let o;switch(s){case T.BYTE:case T.UNSIGNED_BYTE:o=1;break;case T.SHORT:case T.UNSIGNED_SHORT:o=2;break;default:o=4}let c=e.itemSize*o;n===T.ARRAY_BUFFER&&(c=Math.ceil(c/4)*4);const u=j(t*c),f=new DataView(new ArrayBuffer(u));let l=0;for(let x=r;x<r+t;x++){for(let p=0;p<e.itemSize;p++){let d;e.itemSize>4?d=e.array[x*e.itemSize+p]:(p===0?d=e.getX(x):p===1?d=e.getY(x):p===2?d=e.getZ(x):p===3&&(d=e.getW(x)),e.normalized===!0&&(d=H.normalize(d,e.array))),s===T.FLOAT?f.setFloat32(l,d,!0):s===T.INT?f.setInt32(l,d,!0):s===T.UNSIGNED_INT?f.setUint32(l,d,!0):s===T.SHORT?f.setInt16(l,d,!0):s===T.UNSIGNED_SHORT?f.setUint16(l,d,!0):s===T.BYTE?f.setInt8(l,d):s===T.UNSIGNED_BYTE&&f.setUint8(l,d),l+=o}l%c!==0&&(l+=c-l%c)}const g={buffer:this.processBuffer(f.buffer),byteOffset:this.byteOffset,byteLength:u};return n!==void 0&&(g.target=n),n===T.ARRAY_BUFFER&&(g.byteStride=c),this.byteOffset+=u,i.bufferViews.push(g),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const s=this,r=s.json;return r.bufferViews||(r.bufferViews=[]),new Promise(function(t){const n=new FileReader;n.readAsArrayBuffer(e),n.onloadend=function(){const i=k(n.result),o={buffer:s.processBuffer(i),byteOffset:s.byteOffset,byteLength:i.byteLength};s.byteOffset+=i.byteLength,t(r.bufferViews.push(o)-1)}})}processAccessor(e,s,r,t){const n=this.json,i={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let o;if(e.array.constructor===Float32Array)o=T.FLOAT;else if(e.array.constructor===Int32Array)o=T.INT;else if(e.array.constructor===Uint32Array)o=T.UNSIGNED_INT;else if(e.array.constructor===Int16Array)o=T.SHORT;else if(e.array.constructor===Uint16Array)o=T.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)o=T.BYTE;else if(e.array.constructor===Uint8Array)o=T.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(r===void 0&&(r=0),(t===void 0||t===1/0)&&(t=e.count),t===0)return null;const c=Ne(e,r,t);let u;s!==void 0&&(u=e===s.index?T.ELEMENT_ARRAY_BUFFER:T.ARRAY_BUFFER);const f=this.processBufferView(e,o,r,t,u),l={bufferView:f.id,byteOffset:f.byteOffset,componentType:o,count:t,max:c.max,min:c.min,type:i[e.itemSize]};return e.normalized===!0&&(l.normalized=!0),n.accessors||(n.accessors=[]),n.accessors.push(l)-1}processImage(e,s,r,t="image/png"){if(e!==null){const n=this,i=n.cache,o=n.json,c=n.options,u=n.pending;i.images.has(e)||i.images.set(e,{});const f=i.images.get(e),l=t+":flipY/"+r.toString();if(f[l]!==void 0)return f[l];o.images||(o.images=[]);const g={mimeType:t},h=J();h.width=Math.min(e.width,c.maxTextureSize),h.height=Math.min(e.height,c.maxTextureSize);const x=h.getContext("2d",{willReadFrequently:!0});if(r===!0&&(x.translate(0,h.height),x.scale(1,-1)),e.data!==void 0){s!==ie&&console.error("GLTFExporter: Only RGBAFormat is supported.",s),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const d=new Uint8ClampedArray(e.height*e.width*4);for(let m=0;m<d.length;m+=4)d[m+0]=e.data[m+0],d[m+1]=e.data[m+1],d[m+2]=e.data[m+2],d[m+3]=e.data[m+3];x.putImageData(new ImageData(d,e.width,e.height),0,0)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)x.drawImage(e,0,0,h.width,h.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");c.binary===!0?u.push(Le(h,t).then(d=>n.processBufferViewImage(d)).then(d=>{g.bufferView=d})):g.uri=re.getDataURL(h,t);const p=o.images.push(g)-1;return f[l]=p,p}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const s=this.json;s.samplers||(s.samplers=[]);const r={magFilter:N[e.magFilter],minFilter:N[e.minFilter],wrapS:N[e.wrapS],wrapT:N[e.wrapT]};return s.samplers.push(r)-1}async processTextureAsync(e){const r=this.options,t=this.cache,n=this.json;if(t.textures.has(e))return t.textures.get(e);n.textures||(n.textures=[]),e instanceof P&&(e=await this.decompressTextureAsync(e,r.maxTextureSize));let i=e.userData.mimeType;i==="image/webp"&&(i="image/png");const o={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,i)};e.name&&(o.name=e.name),await this._invokeAllAsync(async function(u){u.writeTexture&&await u.writeTexture(e,o)});const c=n.textures.push(o)-1;return t.textures.set(e,c),c}async processMaterialAsync(e){const s=this.cache,r=this.json;if(s.materials.has(e))return s.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;r.materials||(r.materials=[]);const t={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const n=e.color.toArray().concat([e.opacity]);if(S(n,[1,1,1,1])||(t.pbrMetallicRoughness.baseColorFactor=n),e.isMeshStandardMaterial?(t.pbrMetallicRoughness.metallicFactor=e.metalness,t.pbrMetallicRoughness.roughnessFactor=e.roughness):(t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=1),e.metalnessMap||e.roughnessMap){const o=await this.buildMetalRoughTextureAsync(e.metalnessMap,e.roughnessMap),c={index:await this.processTextureAsync(o),texCoord:o.channel};this.applyTextureTransform(c,o),t.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const o={index:await this.processTextureAsync(e.map),texCoord:e.map.channel};this.applyTextureTransform(o,e.map),t.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive;if(Math.max(o.r,o.g,o.b)>0&&(t.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const u={index:await this.processTextureAsync(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(u,e.emissiveMap),t.emissiveTexture=u}}if(e.normalMap){const o={index:await this.processTextureAsync(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),t.normalTexture=o}if(e.aoMap){const o={index:await this.processTextureAsync(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),t.occlusionTexture=o}e.transparent?t.alphaMode="BLEND":e.alphaTest>0&&(t.alphaMode="MASK",t.alphaCutoff=e.alphaTest),e.side===oe&&(t.doubleSided=!0),e.name!==""&&(t.name=e.name),this.serializeUserData(e,t),await this._invokeAllAsync(async function(o){o.writeMaterialAsync&&await o.writeMaterialAsync(e,t)});const i=r.materials.push(t)-1;return s.materials.set(e,i),i}async processMeshAsync(e){const s=this.cache,r=this.json,t=[e.geometry.uuid];if(Array.isArray(e.material))for(let y=0,w=e.material.length;y<w;y++)t.push(e.material[y].uuid);else t.push(e.material.uuid);const n=t.join(":");if(s.meshes.has(n))return s.meshes.get(n);const i=e.geometry;let o;e.isLineSegments?o=T.LINES:e.isLineLoop?o=T.LINE_LOOP:e.isLine?o=T.LINE_STRIP:e.isPoints?o=T.POINTS:o=e.material.wireframe?T.LINES:T.TRIANGLES;const c={},u={},f=[],l=[],g={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},h=i.getAttribute("normal");h!==void 0&&!this.isNormalizedNormalAttribute(h)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(h)));let x=null;for(let y in i.attributes){if(y.slice(0,5)==="morph")continue;const w=i.attributes[y];if(y=g[y]||y.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y)||(y="_"+y),s.attributes.has(this.getUID(w))){u[y]=s.attributes.get(this.getUID(w));continue}x=null;const M=w.array;y==="JOINTS_0"&&!(M instanceof Uint16Array)&&!(M instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),x=O.Utils.toTypedBufferAttribute(w,Uint16Array)):(M instanceof Uint32Array||M instanceof Int32Array)&&!y.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${y}" converted to type FLOAT.`),x=O.Utils.toTypedBufferAttribute(w,Float32Array));const R=this.processAccessor(x||w,i);R!==null&&(y.startsWith("_")||this.detectMeshQuantization(y,w),u[y]=R,s.attributes.set(this.getUID(w),R))}if(h!==void 0&&i.setAttribute("normal",h),Object.keys(u).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const y=[],w=[],E={};if(e.morphTargetDictionary!==void 0)for(const M in e.morphTargetDictionary)E[e.morphTargetDictionary[M]]=M;for(let M=0;M<e.morphTargetInfluences.length;++M){const R={};let V=!1;for(const U in i.morphAttributes){if(U!=="position"&&U!=="normal"){V||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),V=!0);continue}const L=i.morphAttributes[U][M],B=U.toUpperCase(),F=i.attributes[U];if(s.attributes.has(this.getUID(L,!0))){R[B]=s.attributes.get(this.getUID(L,!0));continue}const v=L.clone();if(!i.morphTargetsRelative)for(let I=0,Q=L.count;I<Q;I++)for(let C=0;C<L.itemSize;C++)C===0&&v.setX(I,L.getX(I)-F.getX(I)),C===1&&v.setY(I,L.getY(I)-F.getY(I)),C===2&&v.setZ(I,L.getZ(I)-F.getZ(I)),C===3&&v.setW(I,L.getW(I)-F.getW(I));R[B]=this.processAccessor(v,i),s.attributes.set(this.getUID(F,!0),R[B])}l.push(R),y.push(e.morphTargetInfluences[M]),e.morphTargetDictionary!==void 0&&w.push(E[M])}c.weights=y,w.length>0&&(c.extras={},c.extras.targetNames=w)}const p=Array.isArray(e.material);if(p&&i.groups.length===0)return null;let d=!1;if(p&&i.index===null){const y=[];for(let w=0,E=i.attributes.position.count;w<E;w++)y[w]=w;i.setIndex(y),d=!0}const m=p?e.material:[e.material],A=p?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let y=0,w=A.length;y<w;y++){const E={mode:o,attributes:u};if(this.serializeUserData(i,E),l.length>0&&(E.targets=l),i.index!==null){let R=this.getUID(i.index);(A[y].start!==void 0||A[y].count!==void 0)&&(R+=":"+A[y].start+":"+A[y].count),s.attributes.has(R)?E.indices=s.attributes.get(R):(E.indices=this.processAccessor(i.index,i,A[y].start,A[y].count),s.attributes.set(R,E.indices)),E.indices===null&&delete E.indices}const M=await this.processMaterialAsync(m[A[y].materialIndex]);M!==null&&(E.material=M),f.push(E)}d===!0&&i.setIndex(null),c.primitives=f,r.meshes||(r.meshes=[]),await this._invokeAllAsync(function(y){y.writeMesh&&y.writeMesh(e,c)});const _=r.meshes.push(c)-1;return s.meshes.set(n,_),_}detectMeshQuantization(e,s){if(this.extensionsUsed[G])return;let r;switch(s.array.constructor){case Int8Array:r="byte";break;case Uint8Array:r="unsigned byte";break;case Int16Array:r="short";break;case Uint16Array:r="unsigned short";break;default:return}s.normalized&&(r+=" normalized");const t=e.split("_",1)[0];K[t]&&K[t].includes(r)&&(this.extensionsUsed[G]=!0,this.extensionsRequired[G]=!0)}processCamera(e){const s=this.json;s.cameras||(s.cameras=[]);const r=e.isOrthographicCamera,t={type:r?"orthographic":"perspective"};return r?t.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:t.perspective={aspectRatio:e.aspect,yfov:H.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(t.name=e.type),s.cameras.push(t)-1}processAnimation(e,s){const r=this.json,t=this.nodeMap;r.animations||(r.animations=[]),e=O.Utils.mergeMorphTargetTracks(e.clone(),s);const n=e.tracks,i=[],o=[];for(let u=0;u<n.length;++u){const f=n[u],l=D.parseTrackName(f.name);let g=D.findNode(s,l.nodeName);const h=q[l.propertyName];if(l.objectName==="bones"&&(g.isSkinnedMesh===!0?g=g.skeleton.getBoneByName(l.objectIndex):g=void 0),!g||!h){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',f.name);continue}const x=1;let p=f.values.length/f.times.length;h===q.morphTargetInfluences&&(p/=g.morphTargetInfluences.length);let d;f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(d="CUBICSPLINE",p/=3):f.getInterpolation()===ae?d="STEP":d="LINEAR",o.push({input:this.processAccessor(new b(f.times,x)),output:this.processAccessor(new b(f.values,p)),interpolation:d}),i.push({sampler:o.length-1,target:{node:t.get(g),path:h}})}const c={name:e.name||"clip_"+r.animations.length,samplers:o,channels:i};return this.serializeUserData(e,c),r.animations.push(c),r.animations.length-1}processSkin(e){const s=this.json,r=this.nodeMap,t=s.nodes[r.get(e)],n=e.skeleton;if(n===void 0)return null;const i=e.skeleton.bones[0];if(i===void 0)return null;const o=[],c=new Float32Array(n.bones.length*16),u=new Z;for(let l=0;l<n.bones.length;++l)o.push(r.get(n.bones[l])),u.copy(n.boneInverses[l]),u.multiply(e.bindMatrix).toArray(c,l*16);return s.skins===void 0&&(s.skins=[]),s.skins.push({inverseBindMatrices:this.processAccessor(new b(c,16)),joints:o,skeleton:r.get(i)}),t.skin=s.skins.length-1}async processNodeAsync(e){const s=this.json,r=this.options,t=this.nodeMap;if(s.nodes||(s.nodes=[]),e.pivot!==null)return await this._processNodeWithPivotAsync(e);const n={};if(r.trs){const o=e.quaternion.toArray(),c=e.position.toArray(),u=e.scale.toArray();S(o,[0,0,0,1])||(n.rotation=o),S(c,[0,0,0])||(n.translation=c),S(u,[1,1,1])||(n.scale=u)}else e.matrixAutoUpdate&&e.updateMatrix(),Re(e.matrix)===!1&&(n.matrix=e.matrix.elements);if(e.name!==""&&(n.name=String(e.name)),this.serializeUserData(e,n),e.isMesh||e.isLine||e.isPoints){const o=await this.processMeshAsync(e);o!==null&&(n.mesh=o)}else e.isCamera&&(n.camera=this.processCamera(e));e.isSkinnedMesh&&this.skins.push(e);const i=s.nodes.push(n)-1;if(t.set(e,i),e.children.length>0){const o=[];for(let c=0,u=e.children.length;c<u;c++){const f=e.children[c];if(f.visible||r.onlyVisible===!1){const l=await this.processNodeAsync(f);l!==null&&o.push(l)}}o.length>0&&(n.children=o)}return await this._invokeAllAsync(function(o){o.writeNode&&o.writeNode(e,n)}),i}async _processNodeWithPivotAsync(e){const s=this.json,r=this.options,t=this.nodeMap,n=e.pivot,i={},o=e.quaternion.toArray(),c=[e.position.x+n.x,e.position.y+n.y,e.position.z+n.z],u=e.scale.toArray();S(o,[0,0,0,1])||(i.rotation=o),S(c,[0,0,0])||(i.translation=c),S(u,[1,1,1])||(i.scale=u),i.extras={pivot:n.toArray()},e.name!==""&&(i.name=String(e.name)),this.serializeUserData(e,i);const f=s.nodes.push(i)-1;t.set(e,f);const l={},g=[-n.x,-n.y,-n.z];if(S(g,[0,0,0])||(l.translation=g),e.isMesh||e.isLine||e.isPoints){const p=await this.processMeshAsync(e);p!==null&&(l.mesh=p)}else e.isCamera&&(l.camera=this.processCamera(e));e.isSkinnedMesh&&this.skins.push(e);const x=[s.nodes.push(l)-1];if(e.children.length>0){const p=[];for(let d=0,m=e.children.length;d<m;d++){const A=e.children[d];if(A.visible||r.onlyVisible===!1){const _=await this.processNodeAsync(A);_!==null&&p.push(_)}}p.length>0&&(l.children=p)}return i.children=x,await this._invokeAllAsync(function(p){p.writeNode&&p.writeNode(e,i)}),f}async processSceneAsync(e){const s=this.json,r=this.options;s.scenes||(s.scenes=[],s.scene=0);const t={};e.name!==""&&(t.name=e.name),s.scenes.push(t);const n=[];for(let i=0,o=e.children.length;i<o;i++){const c=e.children[i];if(c.visible||r.onlyVisible===!1){const u=await this.processNodeAsync(c);u!==null&&n.push(u)}}n.length>0&&(t.nodes=n),this.serializeUserData(e,t)}async processObjectsAsync(e){const s=new Y;s.name="AuxScene";for(let r=0;r<e.length;r++)s.children.push(e[r]);await this.processSceneAsync(s)}async processInputAsync(e){const s=this.options;e=e instanceof Array?e:[e],await this._invokeAllAsync(function(t){t.beforeParse&&t.beforeParse(e)});const r=[];for(let t=0;t<e.length;t++)e[t]instanceof Y?await this.processSceneAsync(e[t]):r.push(e[t]);r.length>0&&await this.processObjectsAsync(r);for(let t=0;t<this.skins.length;++t)this.processSkin(this.skins[t]);for(let t=0;t<s.animations.length;++t)this.processAnimation(s.animations[t],e[0]);await this._invokeAllAsync(function(t){t.afterParse&&t.afterParse(e)})}async _invokeAllAsync(e){for(let s=0,r=this.plugins.length;s<r;s++)await e(this.plugins[s])}}class _e{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,s){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const r=this.writer,t=r.json,n=r.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(1-e.penumbra)*e.angle,i.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),n[this.name]||(t.extensions=t.extensions||{},t.extensions[this.name]={lights:[]},n[this.name]=!0);const o=t.extensions[this.name].lights;o.push(i),s.extensions=s.extensions||{},s.extensions[this.name]={light:o.length-1}}}class be{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}async writeMaterialAsync(e,s){if(!e.isMeshBasicMaterial)return;const t=this.writer.extensionsUsed;s.extensions=s.extensions||{},s.extensions[this.name]={},t[this.name]=!0,s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=.9}}class Ce{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const r=this.writer,t=r.extensionsUsed,n={};if(n.clearcoatFactor=e.clearcoat,e.clearcoatMap){const i={index:await r.processTextureAsync(e.clearcoatMap),texCoord:e.clearcoatMap.channel};r.applyTextureTransform(i,e.clearcoatMap),n.clearcoatTexture=i}if(n.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const i={index:await r.processTextureAsync(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};r.applyTextureTransform(i,e.clearcoatRoughnessMap),n.clearcoatRoughnessTexture=i}if(e.clearcoatNormalMap){const i={index:await r.processTextureAsync(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};e.clearcoatNormalScale.x!==1&&(i.scale=e.clearcoatNormalScale.x),r.applyTextureTransform(i,e.clearcoatNormalMap),n.clearcoatNormalTexture=i}s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class Ue{constructor(e){this.writer=e,this.name="KHR_materials_dispersion"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.dispersion===0)return;const t=this.writer.extensionsUsed,n={};n.dispersion=e.dispersion,s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class Fe{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const r=this.writer,t=r.extensionsUsed,n={};if(n.iridescenceFactor=e.iridescence,e.iridescenceMap){const i={index:await r.processTextureAsync(e.iridescenceMap),texCoord:e.iridescenceMap.channel};r.applyTextureTransform(i,e.iridescenceMap),n.iridescenceTexture=i}if(n.iridescenceIor=e.iridescenceIOR,n.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],n.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const i={index:await r.processTextureAsync(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};r.applyTextureTransform(i,e.iridescenceThicknessMap),n.iridescenceThicknessTexture=i}s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class ve{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const r=this.writer,t=r.extensionsUsed,n={};if(n.transmissionFactor=e.transmission,e.transmissionMap){const i={index:await r.processTextureAsync(e.transmissionMap),texCoord:e.transmissionMap.channel};r.applyTextureTransform(i,e.transmissionMap),n.transmissionTexture=i}s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class Oe{constructor(e){this.writer=e,this.name="KHR_materials_volume"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const r=this.writer,t=r.extensionsUsed,n={};if(n.thicknessFactor=e.thickness,e.thicknessMap){const i={index:await r.processTextureAsync(e.thicknessMap),texCoord:e.thicknessMap.channel};r.applyTextureTransform(i,e.thicknessMap),n.thicknessTexture=i}e.attenuationDistance!==1/0&&(n.attenuationDistance=e.attenuationDistance),n.attenuationColor=e.attenuationColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class ze{constructor(e){this.writer=e,this.name="KHR_materials_ior"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const t=this.writer.extensionsUsed,n={};n.ior=e.ior,s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class De{constructor(e){this.writer=e,this.name="KHR_materials_specular"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(we)&&!e.specularIntensityMap&&!e.specularColorMap)return;const r=this.writer,t=r.extensionsUsed,n={};if(e.specularIntensityMap){const i={index:await r.processTextureAsync(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};r.applyTextureTransform(i,e.specularIntensityMap),n.specularTexture=i}if(e.specularColorMap){const i={index:await r.processTextureAsync(e.specularColorMap),texCoord:e.specularColorMap.channel};r.applyTextureTransform(i,e.specularColorMap),n.specularColorTexture=i}n.specularFactor=e.specularIntensity,n.specularColorFactor=e.specularColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class Be{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const r=this.writer,t=r.extensionsUsed,n={};if(e.sheenRoughnessMap){const i={index:await r.processTextureAsync(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};r.applyTextureTransform(i,e.sheenRoughnessMap),n.sheenRoughnessTexture=i}if(e.sheenColorMap){const i={index:await r.processTextureAsync(e.sheenColorMap),texCoord:e.sheenColorMap.channel};r.applyTextureTransform(i,e.sheenColorMap),n.sheenColorTexture=i}n.sheenRoughnessFactor=e.sheenRoughness,n.sheenColorFactor=e.sheenColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class Pe{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const r=this.writer,t=r.extensionsUsed,n={};if(e.anisotropyMap){const i={index:await r.processTextureAsync(e.anisotropyMap)};r.applyTextureTransform(i,e.anisotropyMap),n.anisotropyTexture=i}n.anisotropyStrength=e.anisotropy,n.anisotropyRotation=e.anisotropyRotation,s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class Ge{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(e,s){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const t=this.writer.extensionsUsed,n={};n.emissiveStrength=e.emissiveIntensity,s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class ke{constructor(e){this.writer=e,this.name="EXT_materials_bump"}async writeMaterialAsync(e,s){if(!e.isMeshStandardMaterial||e.bumpScale===1&&!e.bumpMap)return;const r=this.writer,t=r.extensionsUsed,n={};if(e.bumpMap){const i={index:await r.processTextureAsync(e.bumpMap),texCoord:e.bumpMap.channel};r.applyTextureTransform(i,e.bumpMap),n.bumpTexture=i}n.bumpFactor=e.bumpScale,s.extensions=s.extensions||{},s.extensions[this.name]=n,t[this.name]=!0}}class He{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,s){if(!e.isInstancedMesh)return;const r=this.writer,t=e,n=new Float32Array(t.count*3),i=new Float32Array(t.count*4),o=new Float32Array(t.count*3),c=new Z,u=new z,f=new ee,l=new z;for(let h=0;h<t.count;h++)t.getMatrixAt(h,c),c.decompose(u,f,l),u.toArray(n,h*3),f.toArray(i,h*4),l.toArray(o,h*3);const g={TRANSLATION:r.processAccessor(new b(n,3)),ROTATION:r.processAccessor(new b(i,4)),SCALE:r.processAccessor(new b(o,3))};t.instanceColor&&(g._COLOR_0=r.processAccessor(t.instanceColor)),s.extensions=s.extensions||{},s.extensions[this.name]={attributes:g},r.extensionsUsed[this.name]=!0,r.extensionsRequired[this.name]=!0}}O.Utils={insertKeyframe:function(a,e){const r=a.getValueSize(),t=new a.TimeBufferType(a.times.length+1),n=new a.ValueBufferType(a.values.length+r),i=a.createInterpolant(new a.ValueBufferType(r));let o;if(a.times.length===0){t[0]=e;for(let c=0;c<r;c++)n[c]=0;o=0}else if(e<a.times[0]){if(Math.abs(a.times[0]-e)<.001)return 0;t[0]=e,t.set(a.times,1),n.set(i.evaluate(e),0),n.set(a.values,r),o=0}else if(e>a.times[a.times.length-1]){if(Math.abs(a.times[a.times.length-1]-e)<.001)return a.times.length-1;t[t.length-1]=e,t.set(a.times,0),n.set(a.values,0),n.set(i.evaluate(e),a.values.length),o=t.length-1}else for(let c=0;c<a.times.length;c++){if(Math.abs(a.times[c]-e)<.001)return c;if(a.times[c]<e&&a.times[c+1]>e){t.set(a.times.slice(0,c+1),0),t[c+1]=e,t.set(a.times.slice(c+1),c+2),n.set(a.values.slice(0,(c+1)*r),0),n.set(i.evaluate(e),(c+1)*r),n.set(a.values.slice((c+1)*r),(c+2)*r),o=c+1;break}}return a.times=t,a.values=n,o},mergeMorphTargetTracks:function(a,e){const s=[],r={},t=a.tracks;for(let n=0;n<t.length;++n){let i=t[n];const o=D.parseTrackName(i.name),c=D.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){s.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),i=i.clone(),i.setInterpolation(Te)}const u=c.morphTargetInfluences.length,f=c.morphTargetDictionary[o.propertyIndex];if(f===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let l;if(r[c.uuid]===void 0){l=i.clone();const h=new l.ValueBufferType(u*l.times.length);for(let x=0;x<l.times.length;x++)h[x*u+f]=l.values[x];l.name=(o.nodeName||"")+".morphTargetInfluences",l.values=h,r[c.uuid]=l,s.push(l);continue}const g=i.createInterpolant(new i.ValueBufferType(1));l=r[c.uuid];for(let h=0;h<l.times.length;h++)l.values[h*u+f]=g.evaluate(l.times[h]);for(let h=0;h<i.times.length;h++){const x=this.insertKeyframe(l,i.times[h]);l.values[x*u+f]=i.values[h]}}return a.tracks=s,a},toTypedBufferAttribute:function(a,e){const s=new b(new e(a.count*a.itemSize),a.itemSize,!1);if(!a.normalized&&!a.isInterleavedBufferAttribute)return s.array.set(a.array),s;for(let r=0,t=a.count;r<t;r++)for(let n=0;n<a.itemSize;n++)s.setComponent(r,n,a.getComponent(r,n));return s}};export{O as GLTFExporter};
