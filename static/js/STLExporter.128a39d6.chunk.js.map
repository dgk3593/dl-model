{"version":3,"sources":["../node_modules/three/examples/jsm/exporters/STLExporter.js"],"names":["STLExporter","scene","output","options","binary","undefined","objects","triangles","traverse","object","isMesh","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","count","push","object3d","offset","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","Vector3","vB","vC","cb","ab","normal","i","il","length","j","a","getX","b","c","writeFace","fromBufferAttribute","isSkinnedMesh","boneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","subVectors","cross","normalize","copy","setFloat32","x","y","z","vertex"],"mappings":"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","file":"static/js/STLExporter.128a39d6.chunk.js","sourcesContent":["import {\n\tVector3\n} from 'three';\n\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nclass STLExporter {\n\n\tparse( scene, options = {} ) {\n\n\t\tconst binary = options.binary !== undefined ? options.binary : false;\n\n\t\t//\n\n\t\tconst objects = [];\n\t\tlet triangles = 0;\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tconst geometry = object.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\ttriangles += ( index !== null ) ? ( index.count / 3 ) : ( positionAttribute.count / 3 );\n\n\t\t\t\tobjects.push( {\n\t\t\t\t\tobject3d: object,\n\t\t\t\t\tgeometry: geometry\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tlet output;\n\t\tlet offset = 80; // skip header\n\n\t\tif ( binary === true ) {\n\n\t\t\tconst bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\tconst arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\toutput = new DataView( arrayBuffer );\n\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t} else {\n\n\t\t\toutput = '';\n\t\t\toutput += 'solid exported\\n';\n\n\t\t}\n\n\t\tconst vA = new Vector3();\n\t\tconst vB = new Vector3();\n\t\tconst vC = new Vector3();\n\t\tconst cb = new Vector3();\n\t\tconst ab = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\tconst object = objects[ i ].object3d;\n\t\t\tconst geometry = objects[ i ].geometry;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed geometry\n\n\t\t\t\tfor ( let j = 0; j < index.count; j += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( j + 0 );\n\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed geometry\n\n\t\t\t\tfor ( let j = 0; j < positionAttribute.count; j += 3 ) {\n\n\t\t\t\t\tconst a = j + 0;\n\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( binary === false ) {\n\n\t\t\toutput += 'endsolid exported\\n';\n\n\t\t}\n\n\t\treturn output;\n\n\t\tfunction writeFace( a, b, c, positionAttribute, object ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\t\tobject.boneTransform( a, vA );\n\t\t\t\tobject.boneTransform( b, vB );\n\t\t\t\tobject.boneTransform( c, vC );\n\n\t\t\t}\n\n\t\t\tvA.applyMatrix4( object.matrixWorld );\n\t\t\tvB.applyMatrix4( object.matrixWorld );\n\t\t\tvC.applyMatrix4( object.matrixWorld );\n\n\t\t\twriteNormal( vA, vB, vC );\n\n\t\t\twriteVertex( vA );\n\t\t\twriteVertex( vB );\n\t\t\twriteVertex( vC );\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeNormal( vA, vB, vC ) {\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tnormal.copy( cb ).normalize();\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, normal.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeVertex( vertex ) {\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, vertex.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { STLExporter };\n"],"sourceRoot":""}